DiceLoss
class monai.losses.DiceLoss(include_background=True, to_onehot_y=False, sigmoid=False, softmax=False, other_act=None, squared_pred=False, jaccard=False, reduction=mean, smooth_nr=1e-05, smooth_dr=1e-05, batch=False, weight=None, soft_label=False)[source]
Compute average Dice loss between two tensors. It can support both multi-classes and multi-labels tasks. The data input (BNHW[D] where N is number of classes) is compared with ground truth target (BNHW[D]).

Note that axis N of input is expected to be logits or probabilities for each class, if passing logits as input, must set sigmoid=True or softmax=True, or specifying other_act. And the same axis of target can be 1 or N (one-hot format).

The smooth_nr and smooth_dr parameters are values added to the intersection and union components of the inter-over-union calculation to smooth results respectively, these values should be small.

The original papers:

Milletari, F. et. al. (2016) V-Net: Fully Convolutional Neural Networks for Volumetric Medical Image Segmentation. 3DV 2016.

Wang, Z. et. al. (2023) Jaccard Metric Losses: Optimizing the Jaccard Index with Soft Labels. NeurIPS 2023.

Wang, Z. et. al. (2023) Dice Semimetric Losses: Optimizing the Dice Score with Soft Labels. MICCAI 2023.

__init__(include_background=True, to_onehot_y=False, sigmoid=False, softmax=False, other_act=None, squared_pred=False, jaccard=False, reduction=mean, smooth_nr=1e-05, smooth_dr=1e-05, batch=False, weight=None, soft_label=False)[source]
Parameters
:
include_background – if False, channel index 0 (background category) is excluded from the calculation. if the non-background segmentations are small compared to the total image size they can get overwhelmed by the signal from the background so excluding it in such cases helps convergence.

to_onehot_y – whether to convert the target into the one-hot format, using the number of classes inferred from input (input.shape[1]). Defaults to False.

sigmoid – if True, apply a sigmoid function to the prediction.

softmax – if True, apply a softmax function to the prediction.

other_act – callable function to execute other activation layers, Defaults to None. for example: other_act = torch.tanh.

squared_pred – use squared versions of targets and predictions in the denominator or not.

jaccard – compute Jaccard Index (soft IoU) instead of dice or not.

reduction –

{"none", "mean", "sum"} Specifies the reduction to apply to the output. Defaults to "mean".

"none": no reduction will be applied.

"mean": the sum of the output will be divided by the number of elements in the output.

"sum": the output will be summed.

smooth_nr – a small constant added to the numerator to avoid zero.

smooth_dr – a small constant added to the denominator to avoid nan.

batch – whether to sum the intersection and union areas over the batch dimension before the dividing. Defaults to False, a Dice loss value is computed independently from each item in the batch before any reduction.

weight – weights to apply to the voxels of each class. If None no weights are applied. The input can be a single value (same weight for all classes), a sequence of values (the length of the sequence should be the same as the number of classes. If not include_background, the number of classes should not include the background category class 0). The value/values should be no less than 0. Defaults to None.

soft_label – whether the target contains non-binary values (soft labels) or not. If True a soft label formulation of the loss will be used.

Raises
:
TypeError – When other_act is not an Optional[Callable].

ValueError – When more than 1 of [sigmoid=True, softmax=True, other_act is not None]. Incompatible values.

forward(input, target)[source]
Parameters
:
input (Tensor) – the shape should be BNH[WD], where N is the number of classes.

target (Tensor) – the shape should be BNH[WD] or B1H[WD], where N is the number of classes.

Raises
:
AssertionError – When input and target (after one hot transform if set) have different shapes.

ValueError – When self.reduction is not one of [“mean”, “sum”, “none”].

Example

from monai.losses.dice import *  # NOQA
import torch
from monai.losses.dice import DiceLoss
B, C, H, W = 7, 5, 3, 2
input = torch.rand(B, C, H, W)
target_idx = torch.randint(low=0, high=C - 1, size=(B, H, W)).long()
target = one_hot(target_idx[:, None, ...], num_classes=C)
self = DiceLoss(reduction='none')
loss = self(input, target)
assert np.broadcast_shapes(loss.shape, input.shape) == input.shape
Return type
:
Tensor

monai.losses.Dice[source]
alias of DiceLoss

monai.losses.dice[source]
alias of <module ‘monai.losses.dice’ from ‘/home/docs/checkouts/readthedocs.org/user_builds/monai/checkouts/stable/monai/losses/dice.py’>




GeneralizedDiceLoss
class monai.losses.GeneralizedDiceLoss(include_background=True, to_onehot_y=False, sigmoid=False, softmax=False, other_act=None, w_type=square, reduction=mean, smooth_nr=1e-05, smooth_dr=1e-05, batch=False, soft_label=False)[source]
Compute the generalised Dice loss defined in:

Sudre, C. et. al. (2017) Generalised Dice overlap as a deep learning loss function for highly unbalanced segmentations. DLMIA 2017.

Adapted from:
NifTK/NiftyNet

__init__(include_background=True, to_onehot_y=False, sigmoid=False, softmax=False, other_act=None, w_type=square, reduction=mean, smooth_nr=1e-05, smooth_dr=1e-05, batch=False, soft_label=False)[source]
Parameters
:
include_background – If False channel index 0 (background category) is excluded from the calculation.

to_onehot_y – whether to convert the target into the one-hot format, using the number of classes inferred from input (input.shape[1]). Defaults to False.

sigmoid – If True, apply a sigmoid function to the prediction.

softmax – If True, apply a softmax function to the prediction.

other_act – callable function to execute other activation layers, Defaults to None. for example: other_act = torch.tanh.

w_type – {"square", "simple", "uniform"} Type of function to transform ground truth volume to a weight factor. Defaults to "square".

reduction –

{"none", "mean", "sum"} Specifies the reduction to apply to the output. Defaults to "mean".

"none": no reduction will be applied.

"mean": the sum of the output will be divided by the number of elements in the output.

"sum": the output will be summed.

smooth_nr – a small constant added to the numerator to avoid zero.

smooth_dr – a small constant added to the denominator to avoid nan.

batch – whether to sum the intersection and union areas over the batch dimension before the dividing. Defaults to False, intersection over union is computed from each item in the batch. If True, the class-weighted intersection and union areas are first summed across the batches.

soft_label – whether the target contains non-binary values (soft labels) or not. If True a soft label formulation of the loss will be used.

Raises
:
TypeError – When other_act is not an Optional[Callable].

ValueError – When more than 1 of [sigmoid=True, softmax=True, other_act is not None]. Incompatible values.

forward(input, target)[source]
Parameters
:
input (Tensor) – the shape should be BNH[WD].

target (Tensor) – the shape should be BNH[WD].

Raises
:
ValueError – When self.reduction is not one of [“mean”, “sum”, “none”].

Return type
:
Tensor

monai.losses.generalized_dice[source]


DiceCELoss
class monai.losses.DiceCELoss(include_background=True, to_onehot_y=False, sigmoid=False, softmax=False, other_act=None, squared_pred=False, jaccard=False, reduction='mean', smooth_nr=1e-05, smooth_dr=1e-05, batch=False, weight=None, lambda_dice=1.0, lambda_ce=1.0, label_smoothing=0.0)[source]
Compute both Dice loss and Cross Entropy Loss, and return the weighted sum of these two losses. The details of Dice loss is shown in monai.losses.DiceLoss. The details of Cross Entropy Loss is shown in torch.nn.CrossEntropyLoss and torch.nn.BCEWithLogitsLoss(). In this implementation, two deprecated parameters size_average and reduce, and the parameter ignore_index are not supported.

__init__(include_background=True, to_onehot_y=False, sigmoid=False, softmax=False, other_act=None, squared_pred=False, jaccard=False, reduction='mean', smooth_nr=1e-05, smooth_dr=1e-05, batch=False, weight=None, lambda_dice=1.0, lambda_ce=1.0, label_smoothing=0.0)[source]
Parameters
:
loss. (reduction and weight is used for both losses and other parameters are only used for dice)

loss.

include_background – if False channel index 0 (background category) is excluded from the calculation.

to_onehot_y – whether to convert the target into the one-hot format, using the number of classes inferred from input (input.shape[1]). Defaults to False.

sigmoid – if True, apply a sigmoid function to the prediction, only used by the DiceLoss, don’t need to specify activation function for CrossEntropyLoss and BCEWithLogitsLoss.

softmax – if True, apply a softmax function to the prediction, only used by the DiceLoss, don’t need to specify activation function for CrossEntropyLoss and BCEWithLogitsLoss.

other_act – callable function to execute other activation layers, Defaults to None. for example: other_act = torch.tanh. only used by the DiceLoss, not for the CrossEntropyLoss and BCEWithLogitsLoss.

squared_pred – use squared versions of targets and predictions in the denominator or not.

jaccard – compute Jaccard Index (soft IoU) instead of dice or not.

reduction –

{"mean", "sum"} Specifies the reduction to apply to the output. Defaults to "mean". The dice loss should as least reduce the spatial dimensions, which is different from cross entropy loss, thus here the none option cannot be used.

"mean": the sum of the output will be divided by the number of elements in the output.

"sum": the output will be summed.

smooth_nr – a small constant added to the numerator to avoid zero.

smooth_dr – a small constant added to the denominator to avoid nan.

batch – whether to sum the intersection and union areas over the batch dimension before the dividing. Defaults to False, a Dice loss value is computed independently from each item in the batch before any reduction.

weight – a rescaling weight given to each class for cross entropy loss for CrossEntropyLoss. or a weight of positive examples to be broadcasted with target used as pos_weight for BCEWithLogitsLoss. See torch.nn.CrossEntropyLoss() or torch.nn.BCEWithLogitsLoss() for more information. The weight is also used in DiceLoss.

lambda_dice – the trade-off weight value for dice loss. The value should be no less than 0.0. Defaults to 1.0.

lambda_ce – the trade-off weight value for cross entropy loss. The value should be no less than 0.0. Defaults to 1.0.

label_smoothing – a value in [0, 1] range. If > 0, the labels are smoothed by the given factor to reduce overfitting. Defaults to 0.0.

bce(input, target)[source]
Compute Binary CrossEntropy loss for the input logits and target in one single class.

Return type
:
Tensor

ce(input, target)[source]
Compute CrossEntropy loss for the input logits and target. Will remove the channel dim according to PyTorch CrossEntropyLoss: https://pytorch.org/docs/stable/generated/torch.nn.CrossEntropyLoss.html?#torch.nn.CrossEntropyLoss.

Return type
:
Tensor

forward(input, target)[source]
Parameters
:
input (Tensor) – the shape should be BNH[WD].

target (Tensor) – the shape should be BNH[WD] or B1H[WD].

Raises
:
ValueError – When number of dimensions for input and target are different.

ValueError – When number of channels for target is neither 1 (without one-hot encoding) nor the same as input.

Returns
:
value of the loss.

Return type
:
torch.Tensor


DiceFocalLoss
class monai.losses.DiceFocalLoss(include_background=True, to_onehot_y=False, sigmoid=False, softmax=False, other_act=None, squared_pred=False, jaccard=False, reduction='mean', smooth_nr=1e-05, smooth_dr=1e-05, batch=False, gamma=2.0, weight=None, lambda_dice=1.0, lambda_focal=1.0, alpha=None)[source]
Compute both Dice loss and Focal Loss, and return the weighted sum of these two losses. The details of Dice loss is shown in monai.losses.DiceLoss. The details of Focal Loss is shown in monai.losses.FocalLoss.

gamma and lambda_focal are only used for the focal loss. include_background, weight, reduction, and alpha are used for both losses, and other parameters are only used for dice loss.

__init__(include_background=True, to_onehot_y=False, sigmoid=False, softmax=False, other_act=None, squared_pred=False, jaccard=False, reduction='mean', smooth_nr=1e-05, smooth_dr=1e-05, batch=False, gamma=2.0, weight=None, lambda_dice=1.0, lambda_focal=1.0, alpha=None)[source]
Parameters
:
include_background – if False channel index 0 (background category) is excluded from the calculation.

to_onehot_y – whether to convert the target into the one-hot format, using the number of classes inferred from input (input.shape[1]). Defaults to False.

sigmoid – if True, apply a sigmoid function to the prediction, only used by the DiceLoss, don’t need to specify activation function for FocalLoss.

softmax – if True, apply a softmax function to the prediction, only used by the DiceLoss, don’t need to specify activation function for FocalLoss.

other_act – callable function to execute other activation layers, Defaults to None. for example: other_act = torch.tanh. only used by the DiceLoss, not for FocalLoss.

squared_pred – use squared versions of targets and predictions in the denominator or not.

jaccard – compute Jaccard Index (soft IoU) instead of dice or not.

reduction –

{"none", "mean", "sum"} Specifies the reduction to apply to the output. Defaults to "mean".

"none": no reduction will be applied.

"mean": the sum of the output will be divided by the number of elements in the output.

"sum": the output will be summed.

smooth_nr – a small constant added to the numerator to avoid zero.

smooth_dr – a small constant added to the denominator to avoid nan.

batch – whether to sum the intersection and union areas over the batch dimension before the dividing. Defaults to False, a Dice loss value is computed independently from each item in the batch before any reduction.

gamma – value of the exponent gamma in the definition of the Focal loss.

weight – weights to apply to the voxels of each class. If None no weights are applied. The input can be a single value (same weight for all classes), a sequence of values (the length of the sequence should be the same as the number of classes).

lambda_dice – the trade-off weight value for dice loss. The value should be no less than 0.0. Defaults to 1.0.

lambda_focal – the trade-off weight value for focal loss. The value should be no less than 0.0. Defaults to 1.0.

alpha – value of the alpha in the definition of the alpha-balanced Focal loss. The value should be in [0, 1]. Defaults to None.

forward(input, target)[source]
Parameters
:
input (Tensor) – the shape should be BNH[WD]. The input should be the original logits due to the restriction of monai.losses.FocalLoss.

target (Tensor) – the shape should be BNH[WD] or B1H[WD].

Raises
:
ValueError – When number of dimensions for input and target are different.

ValueError – When number of channels for target is neither 1 (without one-hot encoding) nor the same as input.

Returns
:
value of the loss.

Return type
:
torch.Tensor


GeneralizedDiceFocalLoss
class monai.losses.GeneralizedDiceFocalLoss(include_background=True, to_onehot_y=False, sigmoid=False, softmax=False, other_act=None, w_type=square, reduction=mean, smooth_nr=1e-05, smooth_dr=1e-05, batch=False, gamma=2.0, weight=None, lambda_gdl=1.0, lambda_focal=1.0)[source]
Compute both Generalized Dice Loss and Focal Loss, and return their weighted average. The details of Generalized Dice Loss and Focal Loss are available at monai.losses.GeneralizedDiceLoss and monai.losses.FocalLoss.

Parameters
:
include_background (bool, optional) – if False channel index 0 (background category) is excluded from the calculation. Defaults to True.

to_onehot_y – whether to convert the target into the one-hot format, using the number of classes inferred from input (input.shape[1]). Defaults to False.

sigmoid (bool, optional) – if True, apply a sigmoid function to the prediction. Defaults to False.

softmax (bool, optional) – if True, apply a softmax function to the prediction. Defaults to False.

other_act (Optional[Callable], optional) – callable function to execute other activation layers, Defaults to None. for example: other_act = torch.tanh. only used by the GeneralizedDiceLoss, not for the FocalLoss.

w_type (Union[Weight, str], optional) – {"square", "simple", "uniform"}. Type of function to transform ground-truth volume to a weight factor. Defaults to "square".

reduction (Union[LossReduction, str], optional) – {"none", "mean", "sum"}. Specified the reduction to apply to the output. Defaults to "mean". - "none": no reduction will be applied. - "mean": the sum of the output will be divided by the number of elements in the output. - "sum": the output will be summed.

smooth_nr (float, optional) – a small constant added to the numerator to avoid zero. Defaults to 1e-5.

smooth_dr (float, optional) – a small constant added to the denominator to avoid nan. Defaults to 1e-5.

batch (bool, optional) – whether to sum the intersection and union areas over the batch dimension before the dividing. Defaults to False, i.e., the areas are computed for each item in the batch.

gamma (float, optional) – value of the exponent gamma in the definition of the Focal loss. Defaults to 2.0.

weight (Optional[Union[Sequence[float], float, int, torch.Tensor]], optional) – weights to apply to the voxels of each class. If None no weights are applied. The input can be a single value (same weight for all classes), a sequence of values (the length of the sequence hould be the same as the number of classes). Defaults to None.

lambda_gdl (float, optional) – the trade-off weight value for Generalized Dice Loss. The value should be no less than 0.0. Defaults to 1.0.

lambda_focal (float, optional) – the trade-off weight value for Focal Loss. The value should be no less than 0.0. Defaults to 1.0.

Raises
:
ValueError – if either lambda_gdl or lambda_focal is less than 0.

forward(input, target)[source]
Parameters
:
input (torch.Tensor) – the shape should be BNH[WD]. The input should be the original logits due to the restriction of monai.losses.FocalLoss.

target (torch.Tensor) – the shape should be BNH[WD] or B1H[WD].

Raises
:
ValueError – When number of dimensions for input and target are different.

ValueError – When number of channels for target is neither 1 (without one-hot encoding) nor the same as input.

Returns
:
value of the loss.

Return type
:
torch.Tensor



FocalLoss
class monai.losses.FocalLoss(include_background=True, to_onehot_y=False, gamma=2.0, alpha=None, weight=None, reduction=mean, use_softmax=False)[source]
FocalLoss is an extension of BCEWithLogitsLoss that down-weights loss from high confidence correct predictions.

Reimplementation of the Focal Loss described in:

[“Focal Loss for Dense Object Detection”](https://arxiv.org/abs/1708.02002), T. Lin et al., ICCV 2017

“AnatomyNet: Deep learning for fast and fully automated whole-volume segmentation of head and neck anatomy”, Zhu et al., Medical Physics 2018

Example

import torch
from monai.losses import FocalLoss
from torch.nn import BCEWithLogitsLoss
shape = B, N, *DIMS = 2, 3, 5, 7, 11
input = torch.rand(*shape)
target = torch.rand(*shape)
# Demonstrate equivalence to BCE when gamma=0
fl_g0_criterion = FocalLoss(reduction='none', gamma=0)
fl_g0_loss = fl_g0_criterion(input, target)
bce_criterion = BCEWithLogitsLoss(reduction='none')
bce_loss = bce_criterion(input, target)
assert torch.allclose(fl_g0_loss, bce_loss)
# Demonstrate "focus" by setting gamma > 0.
fl_g2_criterion = FocalLoss(reduction='none', gamma=2)
fl_g2_loss = fl_g2_criterion(input, target)
# Mark easy and hard cases
is_easy = (target > 0.7) & (input > 0.7)
is_hard = (target > 0.7) & (input < 0.3)
easy_loss_g0 = fl_g0_loss[is_easy].mean()
hard_loss_g0 = fl_g0_loss[is_hard].mean()
easy_loss_g2 = fl_g2_loss[is_easy].mean()
hard_loss_g2 = fl_g2_loss[is_hard].mean()
# Gamma > 0 causes the loss function to "focus" on the hard
# cases.  IE, easy cases are downweighted, so hard cases
# receive a higher proportion of the loss.
hard_to_easy_ratio_g2 = hard_loss_g2 / easy_loss_g2
hard_to_easy_ratio_g0 = hard_loss_g0 / easy_loss_g0
assert hard_to_easy_ratio_g2 > hard_to_easy_ratio_g0
__init__(include_background=True, to_onehot_y=False, gamma=2.0, alpha=None, weight=None, reduction=mean, use_softmax=False)[source]
Parameters
:
include_background – if False, channel index 0 (background category) is excluded from the loss calculation. If False, alpha is invalid when using softmax.

to_onehot_y – whether to convert the label y into the one-hot format. Defaults to False.

gamma – value of the exponent gamma in the definition of the Focal loss. Defaults to 2.

alpha – value of the alpha in the definition of the alpha-balanced Focal loss. The value should be in [0, 1]. Defaults to None.

weight – weights to apply to the voxels of each class. If None no weights are applied. The input can be a single value (same weight for all classes), a sequence of values (the length of the sequence should be the same as the number of classes. If not include_background, the number of classes should not include the background category class 0). The value/values should be no less than 0. Defaults to None.

reduction –

{"none", "mean", "sum"} Specifies the reduction to apply to the output. Defaults to "mean".

"none": no reduction will be applied.

"mean": the sum of the output will be divided by the number of elements in the output.

"sum": the output will be summed.

use_softmax – whether to use softmax to transform the original logits into probabilities. If True, softmax is used. If False, sigmoid is used. Defaults to False.

Example

import torch
from monai.losses import FocalLoss
pred = torch.tensor([[1, 0], [0, 1], [1, 0]], dtype=torch.float32)
grnd = torch.tensor([[0], [1], [0]], dtype=torch.int64)
fl = FocalLoss(to_onehot_y=True)
fl(pred, grnd)
forward(input, target)[source]
Parameters
:
input (Tensor) – the shape should be BNH[WD], where N is the number of classes. The input should be the original logits since it will be transformed by a sigmoid/softmax in the forward function.

target (Tensor) – the shape should be BNH[WD] or B1H[WD], where N is the number of classes.

Raises
:
ValueError – When input and target (after one hot transform if set) have different shapes.

ValueError – When self.reduction is not one of [“mean”, “sum”, “none”].

ValueError – When self.weight is a sequence and the length is not equal to the number of classes.

ValueError – When self.weight is/contains a value that is less than 0.

Return type
:
Tensor

TverskyLoss
class monai.losses.TverskyLoss(include_background=True, to_onehot_y=False, sigmoid=False, softmax=False, other_act=None, alpha=0.5, beta=0.5, reduction=mean, smooth_nr=1e-05, smooth_dr=1e-05, batch=False, soft_label=False)[source]
Compute the Tversky loss defined in:

Sadegh et al. (2017) Tversky loss function for image segmentation using 3D fully convolutional deep networks. (https://arxiv.org/abs/1706.05721)

Wang, Z. et. al. (2023) Dice Semimetric Losses: Optimizing the Dice Score with Soft Labels. MICCAI 2023.

Adapted from:
NifTK/NiftyNet

__init__(include_background=True, to_onehot_y=False, sigmoid=False, softmax=False, other_act=None, alpha=0.5, beta=0.5, reduction=mean, smooth_nr=1e-05, smooth_dr=1e-05, batch=False, soft_label=False)[source]
Parameters
:
include_background – If False channel index 0 (background category) is excluded from the calculation.

to_onehot_y – whether to convert y into the one-hot format. Defaults to False.

sigmoid – If True, apply a sigmoid function to the prediction.

softmax – If True, apply a softmax function to the prediction.

other_act – if don’t want to use sigmoid or softmax, use other callable function to execute other activation layers, Defaults to None. for example: other_act = torch.tanh.

alpha – weight of false positives

beta – weight of false negatives

reduction –

{"none", "mean", "sum"} Specifies the reduction to apply to the output. Defaults to "mean".

"none": no reduction will be applied.

"mean": the sum of the output will be divided by the number of elements in the output.

"sum": the output will be summed.

smooth_nr – a small constant added to the numerator to avoid zero.

smooth_dr – a small constant added to the denominator to avoid nan.

batch – whether to sum the intersection and union areas over the batch dimension before the dividing. Defaults to False, a Dice loss value is computed independently from each item in the batch before any reduction.

soft_label – whether the target contains non-binary values (soft labels) or not. If True a soft label formulation of the loss will be used.

Raises
:
TypeError – When other_act is not an Optional[Callable].

ValueError – When more than 1 of [sigmoid=True, softmax=True, other_act is not None]. Incompatible values.

forward(input, target)[source]
Parameters
:
input (Tensor) – the shape should be BNH[WD].

target (Tensor) – the shape should be BNH[WD].

Raises
:
ValueError – When self.reduction is not one of [“mean”, “sum”, “none”].

Return type
:
Tensor

ContrastiveLoss
class monai.losses.ContrastiveLoss(temperature=0.5, batch_size=-1)[source]
Compute the Contrastive loss defined in:

Chen, Ting, et al. “A simple framework for contrastive learning of visual representations.” International conference on machine learning. PMLR, 2020. (http://proceedings.mlr.press/v119/chen20j.html)

Adapted from:
Sara-Ahmed/SiT

__init__(temperature=0.5, batch_size=-1)[source]
Parameters
:
temperature (float) – Can be scaled between 0 and 1 for learning from negative samples, ideally set to 0.5.

Raises
:
ValueError – When an input of dimension length > 2 is passed

ValueError – When input and target are of different shapes

forward(input, target)[source]
Parameters
:
input (Tensor) – the shape should be B[F].

target (Tensor) – the shape should be B[F].

Return type
:
Tensor



HausdorffDTLoss
class monai.losses.HausdorffDTLoss(alpha=2.0, include_background=False, to_onehot_y=False, sigmoid=False, softmax=False, other_act=None, reduction=mean, batch=False)[source]
Compute channel-wise binary Hausdorff loss based on distance transform. It can support both multi-classes and multi-labels tasks. The data input (BNHW[D] where N is number of classes) is compared with ground truth target (BNHW[D]).

Note that axis N of input is expected to be logits or probabilities for each class, if passing logits as input, must set sigmoid=True or softmax=True, or specifying other_act. And the same axis of target can be 1 or N (one-hot format).

The original paper: Karimi, D. et. al. (2019) Reducing the Hausdorff Distance in Medical Image Segmentation with Convolutional Neural Networks, IEEE Transactions on medical imaging, 39(2), 499-513

__init__(alpha=2.0, include_background=False, to_onehot_y=False, sigmoid=False, softmax=False, other_act=None, reduction=mean, batch=False)[source]
Parameters
:
include_background – if False, channel index 0 (background category) is excluded from the calculation. if the non-background segmentations are small compared to the total image size they can get overwhelmed by the signal from the background so excluding it in such cases helps convergence.

to_onehot_y – whether to convert the target into the one-hot format, using the number of classes inferred from input (input.shape[1]). Defaults to False.

sigmoid – if True, apply a sigmoid function to the prediction.

softmax – if True, apply a softmax function to the prediction.

other_act – callable function to execute other activation layers, Defaults to None. for example: other_act = torch.tanh.

reduction –

{"none", "mean", "sum"} Specifies the reduction to apply to the output. Defaults to "mean".

"none": no reduction will be applied.

"mean": the sum of the output will be divided by the number of elements in the output.

"sum": the output will be summed.

batch – whether to sum the intersection and union areas over the batch dimension before the dividing. Defaults to False, a loss value is computed independently from each item in the batch before any reduction.

Raises
:
TypeError – When other_act is not an Optional[Callable].

ValueError – When more than 1 of [sigmoid=True, softmax=True, other_act is not None]. Incompatible values.

distance_field(img)
Generate distance transform.

Parameters
:
img (np.ndarray) – input mask as NCHWD or NCHW.

Returns
:
Distance field.

Return type
:
np.ndarray

forward(input, target)[source]
Parameters
:
input (Tensor) – the shape should be BNHW[D], where N is the number of classes.

target (Tensor) – the shape should be BNHW[D] or B1HW[D], where N is the number of classes.

Raises
:
ValueError – If the input is not 2D (NCHW) or 3D (NCHWD).

AssertionError – When input and target (after one hot transform if set) have different shapes.

ValueError – When self.reduction is not one of [“mean”, “sum”, “none”].

Example

import torch
from monai.losses.hausdorff_loss import HausdorffDTLoss
from monai.networks.utils import one_hot
B, C, H, W = 7, 5, 3, 2
input = torch.rand(B, C, H, W)
target_idx = torch.randint(low=0, high=C - 1, size=(B, H, W)).long()
target = one_hot(target_idx[:, None, ...], num_classes=C)
self = HausdorffDTLoss(reduction='none')
loss = self(input, target)
assert np.broadcast_shapes(loss.shape, input.shape) == input.shape
Return type
:
Tensor




